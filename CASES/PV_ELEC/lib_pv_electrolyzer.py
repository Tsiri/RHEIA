import os
import random
import pandas as pd
import numpy as np


class ReadData:

    def __init__(self, filename_climate):
        """

        This class enables to read data from the data files.

        Parameters
        ----------
        filename_climate : str
            The directory of the file with information on the
            solar irradiance.

        """
        self.filename_climate = filename_climate
        self.path = os.path.dirname(os.path.abspath(__file__))

    def load_climate(self):
        """

        This method loads the hourly solar irradiance data,
        situated in the 'sol_irr' column of the climate data file.

        Returns
        -------
        sol_irr : ndarray
            The hourly solar irradiance data for a Typical
            Meteorological Year. (8760 elements)

        """
        data = pd.read_csv(self.filename_climate)
        sol_irr = data['sol_irr'].to_numpy()

        return sol_irr

    def load_parameters(self):
        """

        This method loads the deterministic values of the model
        parameters, defined in the design_space file. This is
        useful when the deterministic performance of a specific
        design needs to be evaluated.

        Returns
        -------
        param_dict : dict
            Dictionary with the names of the model parameters
            and the corresponding deterministic values.

        """
        param_dict = {}
        design_space = os.path.join(self.path, 'design_space')

        with open(design_space, 'r') as f:
            for line in f:
                tmp = line.split()
                if tmp[1] == 'par':
                    param_dict[tmp[0]] = float(tmp[2])

        return param_dict


class Evaluation:

    def __init__(self, G, parameters):
        """

        This class evaluates the photovoltaic-electrolyzer system.
        For a given design, the solar irradiance and the characterization
        of the model parameters, the levelized cost of hydrogen and the
        annual hydrogen production are quantified.

        Parameters
        ----------
        G : ndarray
            The hourly solar irradiance for the evaluated year. (8760 elements)
        parameters : dict
            Dictionary with the model parameters and design variables values.

        """
        self.parameters = parameters
        self.G = G * self.parameters['sol_irr']
        self.length = len(self.G)

        self.lifetime_system = 20.
        self.pv_power_consumed = 0.
        self.m_h2 = 0.
        self.running_hours_pem = 0.

    def photovoltaic(self):
        """

        The power produced by the photovoltaic array is
        quantified for each hour and returned in an array.

        Returns
        -------
        pv_power : ndarray
            The hourly photovoltaic power production.

        """

        pv_power = np.zeros(self.length)
        for i in range(self.length):
            if self.G[i] > 0.:
                pv_power[i] = min(
                    (1. + self.parameters['power_tol_pv'] / 100.)
                    * self.G[i] * self.parameters['n_pv'],
                    self.parameters['n_dcdc_pv'] * 1e3
                ) * self.parameters['eff_dcdc']

        return pv_power

    def electrolyzer(self, power):
        """

        The hydrogen production per hour, in function of
        the power supplied to the electrolyzer. The
        produced hydrogen is quantified in kg.

        Parameters
        ----------
        power : float
            The power supplied to the electrolyzer array in W.

        Returns
        -------
        m_h2 : float
            The hourly hydrogen production in kg.

        """

        m_h2 = self.parameters['eff_pem'] * power * 3600. / 120e6

        return m_h2

    def fill_electrolyzer(self, power_elec):
        """

        This method evaluates if the power generated by the
        photovoltaic array lies within the operating range
        of the electrolyzer array. If yes, the power is supplied
        to the electrolyzer array and the produced hydrogen is
        quantified. If the supplied power is larger than the
        electrolyzer capacity, than the nominal power is supplied.
        Finally, the operating hours of the electrolyzer array is
        increased by 1.

        Parameters
        ----------
        power_elec : float
            The power supplied to the electrolyzer array.

        Returns
        -------
        m_h2 : float
            The hydrogen produced during the respective hour.

        """

        if power_elec > self.parameters['n_pem'] * 10.:

            power_elec = min(power_elec, self.parameters['n_pem'] * 1e3)

            m_h2 = self.electrolyzer(power_elec)

            self.running_hours_pem += 1.

            self.pv_power_consumed += power_elec

        else:
            m_h2 = 0.

        return m_h2

    def evaluation(self):
        """

        This is the main method of the Evaluation class.
        In this method, the hourly photovoltaic power is
        quantified first. Then, for each hour, the hydrogen
        is determined. Finally, the electrolyzer lifetime and
        the system cost are determined.

        """
        self.pv_power = self.photovoltaic()

        for i in self.pv_power:

            self.m_h2 += self.fill_electrolyzer(i)

        self.lifetime()
        self.cost()

    def lifetime(self):
        """

        The lifetime method determines the lifetime of
        the electrolyzer array, based on the number of
        operating hours during the evaluated year.

        """

        if self.running_hours_pem == 0.:
            self.life_pem = 1e8
        else:
            self.life_pem = self.parameters['life_pem'] / \
                self.running_hours_pem

    def cost(self):
        """

        Based on the capital recovery factor, the CAPEX,
        OPEX and replacement cost of the system components,
        the levelized cost of hydrogen is determined.

        """

        lifetime = self.lifetime_system

        inv_rate = (
            self.parameters['int_rate'] - self.parameters['infl_rate']) / (
            1. + self.parameters['infl_rate'])
        CRF = (((1. + inv_rate)**lifetime - 1.) /
               (inv_rate * (1. + inv_rate)**lifetime))**(-1)

        self.pv_cost = self.parameters['n_pv'] * (
            CRF * self.parameters['capex_pv'] + self.parameters['opex_pv'])
        self.pv_dcdc_cost = self.parameters['n_dcdc_pv'] * (
            self.parameters['capex_dcdc'] *
            (CRF + self.parameters['opex_dcdc']))
        components_cost = self.pv_cost + self.pv_dcdc_cost

        self.pem_cost = self.parameters['n_pem'] * (
            self.parameters['capex_pem'] *
            (CRF + self.parameters['opex_pem']))
        components_cost += self.pem_cost

        ARC = 0
        ARC += CRF * sum([(1. + inv_rate)**(-(i + 1.) * self.life_pem) *
                          self.parameters['n_pem'] *
                          self.parameters['repl_pem'] *
                          self.parameters['capex_pem'] for
                          i in range(int(lifetime / self.life_pem))])

        cost = ARC + components_cost
        if self.m_h2 < 1e-5:
            self.lcoh = 1e3 + 1e5 * random.random()
        else:
            self.lcoh = cost / self.m_h2

    def print_results(self):
        """

        This method prints the levelized cost of hydrogen,
        the hydrogen production, the annual energy produced
        by the photovoltaic array, the energy consumed by
        the electrolyzer array and the lifetime of the
        electrolyzer array.

        """

        print('outputs:')
        print('LCOH:'.ljust(30) + '%.2f euro/kg' % self.lcoh)
        print('m_h2:'.ljust(30) + '%.2f kg' % self.m_h2)
        print('PV electricity generated:'.ljust(30) +
              '%.2f MWh' % (sum(self.pv_power) / 1e6))
        print(
            'PV electricity consumed:'.ljust(30) + '%.2f MWh' %
            (self.pv_power_consumed / 1e6))
        print('self-consumption ratio:'.ljust(30) + '%.2f %%' %
              (1e2 * self.pv_power_consumed / sum(self.pv_power)))
        print('life electrolyzer:'.ljust(30) + '%.2f year' % self.life_pem)
