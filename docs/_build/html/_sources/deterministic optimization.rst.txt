.. _lab:deterministicoptimization:

deterministic optimization
==========================

This includes:

- characterizing the NSGA-II
- the design variables
- tips for population and generation size
- setting up the dictionary
- ...

The deterministic optimization procedure optimizes the multiple objectives by controlling the design variables. 
The multi-objective optimization algorithm is NSGA-II. More information on NSGA-II is available in :ref:`lab:ssnsga2`.
The design variables and model parameters are characterized in the :file:`design_space` folder. 
More information on characterizing this file is available in :ref:`lab:ssdesignspace`.  
The model returns the objective values through the function `evaluate()` described in `tc_description.py`.

run optimization
----------------

First, the optimization module should be imported::

    import ergo_framework.OPT.optimization as ergo_opt

To characterize the optimization, the following dictionary with parameters related to the case and to the optimizer should be completed::

    dict_opt = {'case':                case_name,
                'objectives':          {opt_type: weights}, 
                'stop':                ('BUDGET', comp_budget),
                'n jobs':              n_jobs, 

                'population number':   n_pop,
                'x0':                  (pop_type, pop_method), 
                'cxProb':              c_prob,
                'mutProb':             mut_prob,
                'eta':                 eta,

                'print results light': [light_bool, gen_step],
                'results dir':         directory,
                }

The items of the optimization dictionary are described in the following subsections. This dictionary is used as the argument for the `run_opt()` function, 
which initiates the optimization procedure::

    ergo_opt.run_opt(dict_opt)

'case': case_name
^^^^^^^^^^^^^^^^^

The string `case_name` corresponds to the name of the case. 
This name should be equal to the name of the folder that comprises the case, which situates in the folder that contains the cases `TC`. 
The name of the folder should be written in capital letters. To illustrate, if the optimization case is defined in `TC\\CASE_1`, 
the dictionary includes the following item::

		'case': 'CASE_1'

'objectives': {opt_type: (weights)} 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the `objectives` key, the optimization type and the weigths for the objectives should be specified. 
Two optimization types are available: deterministic optimization 'DET' and robust optimization 'ROB'. 
In this case, deterministic optimization is desired, which means that the opt_type string should be defined by 'DET'. 
The weights are defined in a tuple and determine if the objective is either maximized or minimized.
When minimization of an objective is desired, the weigth corresponds to a negative number (i.e. -1). 
Instead, when maximization is desired, the weight corresponds to a positive number (e.g. 1). 
Hence, for 2 objectives which should be minimized simultaneously, the dictionary item reads::

	'objectives': {'DET': (-1,-1)}

Alternatively, maximizing the first objective and minimizing the second objective corresponds to::

	'objectives': {'DET': (1,-1)}

'stop': ('BUDGET', comp_budget)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The stopping criterium for the optimization is defined by the computational budget, i.e. the number of model evaluations. 
This is a common engineering stopping criterium, which is defined based on the time available
to perform the optimization. To illustrate, when the system model takes 10 seconds to evaluate and 4 cores are available for parallel processing, 
the computational budget for an optimization procedure of 1 hour is equal to 1440.
The allocation of this computational budget through the integer `comp_budget` is illustrated below::

	'stop': ('BUDGET', 1440)

'n jobs': n_jobs
^^^^^^^^^^^^^^^^

The number of parallel processes can be defined by the number of available cores on the CPU. 
To illustrate, when 4 cores are available, the item can be defined by::

	'n jobs': 4
 
'population number': n_pop
^^^^^^^^^^^^^^^^^^^^^^^^^^

The population number corresponds to the number of samples contained in a single population. 
After each evaluation of the entire population, the optimizer generates a new population with an equal number of samples.
This iterative process continues until the predefined computational budget is met. 
Hence, in the previous example with a computational budget of 1440 model evaluations, a population size of 20 will lead to 72 generations::

	'population number': 20

Note that when the population number and computational budget do not result in an integer for the number of generations, 
the number of generations is rounded up to the nearest integer.  


.. _lab:ssx0:

'x0': (pop_type, pop_method) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Information can be provided to characterize the starting population. If no information is available on the starting population, 
the population can be generated automatically
by defining the string `pop_type` with 'AUTO'. When 'AUTO' is selected, there are two ways of generating the population automatically: 
randomly (`pop_method` = 'RANDOM') or through 
Latin Hypercube Sampling (`pop_method` = 'LHS'). To illustrate, generating the first population through LHS is done through the following item in the dictionary::

	'x0': ('AUTO', 'LHS')

Alternatively, when information on the starting population is available, the `pop_type` should be defined by 'CUSTOM'. 
In that case, the starting population should be provided in a separate file,
located in the case folder. The name of the file corresponds to the string that defines `pop_method`. 
To illustrate for CASE_1, with a starting population saved in TC\\CASE_1\\x0_start, the item is defined as::

	'x0': ('CUSTOM', 'x0_start')

The starting population file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The extensionless file should contain a number of samples equal to the population size. 
Each sample is characterized by the a number of values equal to the number of design variables, delimited by a white space.
Each value should situate between the lower bound and upper bound of the corresponding design variable, 
in the order of appearance of the design variables in the :file:`design_space` file.
The file should start with a `-` on the first line. The sample characterization starts from the second line.

Example: 
The following design variables are defined in :file:`design_space`::

	var_1 var 1 3
	var_2 var 0.4 0.9
	var_3 var 12 15

Then, for a population size of 5, a suitable characterization of the starting population file is::

	-
	1.43 0.78 13.9
	2.97 0.44 12.1
	1.12 0.64 14.2
	2.31 0.51 14.5
	2.05 0.88 13.6

'cxProb': c_prob
^^^^^^^^^^^^^^^^

The crossover probability `c_prob`.

'mutProb': mut_prob
^^^^^^^^^^^^^^^^^^^

The mutation probability `mut_prob`.

'eta': eta
^^^^^^^^^^


.. _lab:detprintreslight:

'print results light': [light_bool, gen_step]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For every optimization case, three different files are generated and continuously appended while the optimization is running:
A status file which saves the generation number and the computational budget spent after each generation;
a file with the population for each generation; a file with the fitness values for each population.
When the computational budget is large and a significant number of design variables are present in the optimization problem,
these three result files can become large, i.e. several MB. Therefore, the framework provides the option to avoid saving each generation.
By setting the light_bool to True and providing the step size `gen_step` for each saved generation, the files size can be significantly reduced.
To illustrate, to save only generation 4, 8, 12, 16 and 20 in a case for which 20 generations are expected based on the computational budget, the following item can be provided in the dictionary::

'print results light': [True, 4]

Alternatively, when every generation can be saved, the item results in::

'print results light': [False]

'results dir': directory
^^^^^^^^^^^^^^^^^^^^^^^^

The results directory corresponds to the folder where the results are stored. 
For an illustrative CASE_1, the results can be saved in the folder RESULTS\\CASE_1\\det\\results_1 by initiating the following key-value pair in the dictionary::

'results dir': results_1

If previous results exist in this directory, the optimization procedure continues from the last, previously generated, population. 
Also the characterization of the initial population in :ref:`lab:ssx0rob` is ignored. However, the computational budget is renewed. 


optimization dictionary example
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When combining the examples in the previous section, a configurated optimization dictionary looks as follows::

    dict_opt = {'case':                'CASE_1',
                'objectives':          {'DET': (-1,-1)}, 
                'stop':                ('BUDGET', 1440),
                'n jobs':              4, 

                'population number':   20,
                'x0':                  ('AUTO', 'LHS'), 
                'cxProb':              6,
                'mutProb':             0.9,
                'eta':                 0.2,

                'print results light': [False],
                'results dir':         'results_1',
                }

The post-processing of the results is described in :ref:`lab:optimizationresults`.






